# `namespace`v1実装までの会話

## 実装計画草案

---

> me  

あなたには名前空間をデータベースに収容するためのスキーマと，パーサーを考えてもらいます．先ずどのような方法で名前空間ごとにそれぞれの要素が定義されているかくべするために必要なことなどを含めてステップバイステップで考えてください．

---

> gemini 2.5 pro preview

了解しました。C++の名前空間 (`namespace`) を解析し、データベースに情報を格納するための機能追加について、ステップバイステップで考察します。

### Step 1: 名前空間の特性と記録すべき情報

まず、名前空間のどのような情報を記録する必要があるかを考えます。

1.  **名前空間自体の定義:**
    * どの名前空間が存在するか？ (例: `std`, `MyLib`, `MyLib::Utils`)
    * 名前空間の名前は何か？ (匿名名前空間 `namespace { ... }` も区別する必要がある)
    * 名前空間はネストしているか？ 親の名前空間は何か？ (例: `Utils` の親は `MyLib`)
    * どこで定義されているか？ (ファイルパスと行番号)

2.  **名前空間に属する要素:**
    * 各関数、変数、クラス、構造体、列挙型、typedef がどの名前空間に属しているか？
    * グローバルスコープ（どの名前空間にも属さない）の要素も区別する必要がある。

### Step 2: データベーススキーマの設計

既存のスキーマを拡張して名前空間を表現する方法を検討します。新しいテーブルを追加するアプローチが最も柔軟性が高いでしょう。

1.  **新しい `namespaces` テーブルの作成:**
    * 名前空間自体の情報を格納するためのテーブルです。
    * **カラム案:**
        * `id` (INTEGER PRIMARY KEY AUTOINCREMENT): 名前空間レコードの一意なID。
        * `name` (TEXT): 名前空間の名前。`std`, `MyLib` など。
            * **匿名名前空間:** 特定の識別子（例: `(anonymous)`）を使用するか、`name` を NULL にしてフラグ (`is_anonymous` INTEGER) を持たせるか。`(anonymous)` のような名前を使う方がシンプルかもしれません。
            * **グローバルスコープ:** これも特別なレコードとして扱う必要があり、`id=1, name='(global)'` のようなレコードを初期データとして持つと便利です。
        * `parent_namespace_id` (INTEGER, FOREIGN KEY REFERENCES namespaces(id) ON DELETE CASCADE): 親の名前空間の `id`。トップレベル（グローバル直下）の名前空間やグローバルスコープ自体は `NULL`。これによりネスト構造を表現します。
        * `file_id` (INTEGER NOT NULL, FOREIGN KEY REFERENCES files(id) ON DELETE CASCADE): この名前空間定義が**最初に見つかった**ファイルのID。分割定義を考慮すると少し曖昧になる可能性がありますが、主要な定義場所を示す指標にはなります。
        * `location` (TEXT): 名前空間定義 (`namespace N { ...`) が開始されるソースコード上の位置 (`filename:line:column`)。
        * `full_qualified_name` (TEXT UNIQUE): 完全修飾名 (例: `MyLib::Utils`, `MyLib::(anonymous)`, `(global)` など)。これを UNIQUE にすることで、同じ名前空間が異なるファイルで定義されても（分割定義）、DB内で一意に識別しやすくなります。ただし、これを正確に生成・管理するロジックがパーサー側で必要になります。

2.  **既存の定義テーブルへの参照追加:**
    * 以下のテーブルに `namespace_id` カラムを追加します。
        * `functions`
        * `variables`
        * `structs_unions`
        * `enums`
        * `typedefs`
    * **カラム定義:** `namespace_id` INTEGER, FOREIGN KEY REFERENCES `namespaces`(`id`) ON DELETE CASCADE
    * この `namespace_id` は、その要素が属する名前空間を示します。グローバルスコープに属する場合は、`(global)` スコープに対応する `namespaces.id` (例: 1) を格納します。
    * **注意:** マクロ (`macros` テーブル) はプリプロセッサによって処理され、C++の名前空間スコープに属さないため、`namespace_id` は不要です。

### Step 3: パーサー (`header_parser.py`, `impl_parser.py`) の改修計画

Clang の AST (Abstract Syntax Tree) を走査して名前空間情報を抽出・記録するようにパーサーを改修します。

1.  **AST走査の準備:**
    * `traverse_ast` 関数（またはそれを呼び出す関数）で、現在の名前空間スコープを追跡するためのメカニズムを導入します。ネストに対応するため、現在の `namespace_id` を保持するスタックが適しています。
    * 走査開始時、スタックにはグローバルスコープの `namespace_id` (例: 1) のみを入れておきます。

2.  **名前空間定義 (`CursorKind.NAMESPACE`) の処理:**
    * `traverse_ast` 内で `cursor.kind == CursorKind.NAMESPACE` を検出します。
    * **名前空間名の取得:** `cursor.spelling` で名前を取得します。
    * **匿名判定:** `cursor.displayname == ""` や `cursor.is_anonymous()` (利用可能なら) で匿名名前空間かどうかを判定します。
    * **親IDの取得:** 現在のスコープスタックのトップにある `namespace_id` を親IDとして取得します。
    * **完全修飾名の生成:** 親の名前空間の `full_qualified_name` と現在の名前空間名を結合して生成します (例: 親が `MyLib` で現在が `Utils` なら `MyLib::Utils`)。匿名の場合は `Parent::(anonymous)` のようにします。
    * **データベースへの登録:**
        * `full_qualified_name` をキーにして `namespaces` テーブルを検索します。
        * 存在しなければ、新しいレコードとして `name`, `parent_namespace_id`, `file_id`, `location`, `full_qualified_name` を挿入し、新しい `id` を取得します。
        * 存在すれば、その `id` を使用します。（`location` や `file_id` は最初に見つかったものを保持するか、更新するかは設計次第ですが、通常は最初のもので良いでしょう）。
    * **スコープの更新:** 取得した `namespace_id` をスコープスタックにプッシュします。
    * **子の走査:** `cursor.get_children()` で取得した子ノードに対して `traverse_ast` を再帰呼び出しします。
    * **スコープの復元:** その名前空間ノードのすべての子の走査が終わったら、スコープスタックから現在の `namespace_id` をポップします。

3.  **各種定義要素の処理:**
    * `FUNCTION_DECL`, `VAR_DECL`, `STRUCT_DECL`, `UNION_DECL`, `ENUM_DECL`, `TYPEDEF_DECL` などを検出した際、現在のスコープスタックのトップにある `namespace_id` を取得します。
    * 各テーブル (`functions`, `variables` など) にデータを挿入する際に、この取得した `namespace_id` も一緒にカラムに含めます。

4.  **グローバルスコープ要素の処理:**
    * `traverse_ast` の開始時（またはトップレベルの要素を処理する際）、スコープスタックにはグローバルスコープの `namespace_id` (例: 1) が入っています。名前空間定義 (`NAMESPACE`) に入る前に検出された要素は、自動的にこのグローバルスコープの `namespace_id` が割り当てられます。

### Step 4: 実装とテスト

1.  **`setup_database` 関数の更新:** 新しい `namespaces` テーブルの CREATE 文と、既存テーブルへの `namespace_id` カラム追加の ALTER 文 (または CREATE 文の修正) を追加します。グローバルスコープ用レコードの初期挿入処理も追加します。
2.  **`traverse_ast` 関数の修正:** 上記 Step 3 のロジックを実装します。スコープスタックの管理、`NAMESPACE` カーソルの処理、各定義要素への `namespace_id` 割り当てを行います。
3.  **テストケースの作成:**
    * グローバルスコープの要素を持つコード。
    * 単純な名前空間を持つコード。
    * ネストした名前空間を持つコード。
    * 匿名名前空間を持つコード。
    * 同じ名前空間が複数のファイルで定義されるコード (分割定義)。
4.  **テストの実行:** 作成したテストケースでパーサーを実行し、`namespaces` テーブルと各定義テーブルの `namespace_id` が正しく格納されているかを確認するテストを作成・実行します。

このステップバイステップのアプローチにより、C++の名前空間を体系的に解析し、データベースに格納する機能を実装できるはずです。

---

## 実装計画書作成

### `Step 1: 名前空間の特性と記録すべき情報`に関して

> me  

`Step 1: 名前空間の特性と記録すべき情報`に関して，実装する手前までくらいの具体的な内容の計画書をステップバイステップで書いてください．

> gemini 2.5 pro preview

はい、承知いたしました。「Step 1: 名前空間の特性と記録すべき情報」について、実装手前までの具体的な計画書をステップバイステップで記述します。

---

## 名前空間情報の記録に関する計画書 (Step 1 詳細)

### 1. 目的とスコープ

**1.1. 目的**
C++ソースコードにおける名前空間の定義と、各プログラム要素（関数、変数、型定義など）がどの名前空間に属しているかを正確に識別し、データベースに記録可能にすること。これにより、コードの構造理解、シンボル解決の補助、リファクタリング支援などの基盤情報とする。

**1.2. 今回のスコープ**
* **記録対象:**
    * 名前付き名前空間 (`namespace MyNamespace { ... }`)
    * ネストした名前空間 (`namespace N1 { namespace N2 { ... } }`)
    * 匿名名前空間 (`namespace { ... }`)
    * グローバル名前空間 (明示的な `namespace` キーワードがないトップレベルスコープ)
    * 上記名前空間内に直接定義された要素 (関数、変数、クラス/構造体/共用体、列挙型、typedef) とその所属関係。
* **スコープ外 (今回は記録しない or 限定的な扱い):**
    * `using`宣言 (`using std::cout;`) および `using`ディレクティブ (`using namespace std;`) の詳細な影響範囲の追跡。これらは名前解決に使われるが、定義そのものではないため、今回の主眼ではない。
    * 名前空間エイリアス (`namespace Alias = N1::N2;`) の定義と解決。
    * インライン名前空間 (`inline namespace`) の特殊な振る舞い（メンバーが親名前空間のメンバーとしても扱われる点）の完全なエミュレーション。インライン名前空間自体は通常の名前空間として定義を記録するが、「インラインである」という属性は今回必須とはしない（将来的な拡張は可能）。
    * 複数の翻訳単位 (.cppファイル) にまたがる名前空間定義の完全な統合。パーサーはファイルごとに実行されるため、各ファイル内で観測された名前空間情報を記録する。データベースレベルでの統合は別課題とする。

### 2. 記録対象となる「名前空間」の定義と属性

**2.1. 名前空間エンティティの定義**
ソースコード上で `namespace Name { ... }` または `namespace { ... }` によって定義されるスコープ、および暗黙的に存在するグローバルスコープを「名前空間エンティティ」として扱う。

**2.2. 名前空間エンティティの必須属性**
各名前空間エンティティについて、以下の情報を記録する。

* **2.2.1. 一意識別子 (ID)**
    * 内容: データベース内で各名前空間エンティティを一意に識別するためのID。
    * データ型: INTEGER (PRIMARY KEY, AUTOINCREMENT)
* **2.2.2. 名前 (Name)**
    * 内容: 名前空間の名前。
    * データ型: TEXT
    * 例: `"MyNamespace"`, `"N2"`
    * 特殊ケース:
        * **匿名名前空間の場合:** `"(anonymous)"` のような予約文字列を格納する。ファイルごとに一意性を保つため、実際にはパーサー実行時に内部的に生成される一意な名前（例: `"(anonymous)_fileId_count"`）や、FQNで区別する。
        * **グローバル名前空間の場合:** `"(global)"` という予約文字列を格納する。
* **2.2.3. 親名前空間ID (Parent Namespace ID)**
    * 内容: ネストしている場合、直接の親となる名前空間エンティティのID。
    * データ型: INTEGER (NULL許容, 外部キーとして自身のテーブルのIDを参照)
    * 特殊ケース:
        * **グローバル名前空間の場合:** `NULL` とする。
        * **グローバル直下の名前空間の場合:** グローバル名前空間のIDを参照する。
* **2.2.4. 定義ファイルID (File ID)**
    * 内容: この名前空間定義が出現したソースファイルのID (`files`テーブルのID)。
    * データ型: INTEGER (NOT NULL, 外部キーとして`files.id`を参照)
* **2.2.5. 定義位置 (Location)**
    * 内容: 名前空間定義 (`namespace Name {` の開始位置) のファイル名、行番号、カラム番号。
    * データ型: TEXT
    * フォーマット: `"filename:line:column"`
* **2.2.6. 完全修飾名 (Full Qualified Name - FQN)**
    * 内容: グローバル名前空間からのパスを含む一意な名前。
    * データ型: TEXT (UNIQUE制約を検討)
    * 生成ルール:
        * グローバル名前空間: `"(global)"`
        * トップレベル名前空間 `N`: `"(global)::N"`
        * ネストした名前空間 `M` (親が `"(global)::N"`): `"(global)::N::M"`
        * 匿名名前空間 (親が `"(global)::N"`): `"(global)::N::(anonymous)_suffix"` のような形式。suffix はファイル内での出現順などで一意にする。
    * 役割: 異なるファイルや異なる親の下にある同名の名前空間を区別する。データベース内で名前空間を一意に参照する際のキーとなる。

**2.3. グローバルスコープの扱い**
* 明示的な名前空間宣言の外側はすべてグローバルスコープとして扱う。
* `namespaces` テーブルには、例えば `id=1`, `name='(global)'`, `parent_namespace_id=NULL`, `file_id=NULL` (または特別なファイルID), `location='N/A'`, `full_qualified_name='(global)'` のような特別なレコードをあらかじめ用意するか、パーサーが最初に処理するファイルで動的に作成する。

**2.4. 匿名名前空間の扱い**
* Clang AST上で `cursor.is_anonymous()` (または `cursor.displayname == ""` など) で識別する。
* `name` 属性には `"(anonymous)"` のような固定文字列を使用し、FQNで一意性を担保する。例えば、同じファイル内で複数の匿名名前空間がある場合は、`FQN` の末尾にインデックスやハッシュを追加する（例: `ParentFQN::(anonymous)_1`, `ParentFQN::(anonymous)_2`）。
* 定義位置が異なる匿名名前空間は、別個のエンティティとして記録される。

**2.5. ネストした名前空間の扱い**
* `parent_namespace_id` 属性を使用して階層構造を表現する。
* FQN は親のFQNをプレフィックスとして構築される (例: `ParentFQN::ChildName`)。

**2.6. 分割定義された名前空間の扱い (同一ファイル内および複数ファイル間)**
* **方針:** FQN (`full_qualified_name`) が同じであれば、それは論理的に同一の名前空間と見なす。
* **`namespaces` テーブルへの登録:**
    * 最初の出現時にFQNに基づいて `namespaces` テーブルにレコードを作成する。
    * 以降、同じFQNを持つ名前空間定義が見つかった場合、既存のレコードを使用する。`location` や `file_id` は、最初の定義を保持するか、あるいは別途「定義箇所リスト」のような関連テーブルで管理するか検討が必要。今回は**最初の定義のみを代表**として記録する方針とする。これにより `namespaces` テーブルの `file_id` と `location` は「このFQNの名前空間が最初に出現した場所」を指すことになる。
* **パーサーの役割:** AST走査中にFQNを正確に生成し、データベースに問い合わせて既存IDを取得するか、新規登録するかを判断する。

### 3. 記録対象となる「名前空間内の要素」と名前空間との関連付け

**3.1. 対象要素**
既存のパーサーが記録対象としている以下の要素。
* 関数 (`functions` テーブル)
* 変数 (`variables` テーブル)
* クラス、構造体、共用体 (`structs_unions` テーブル)
* 列挙型 (`enums` テーブル)
* Typedef (`typedefs` テーブル)

**3.2. 関連付け方法**
上記各要素のテーブルに、新たに `namespace_id` (INTEGER) カラムを追加する。
* この `namespace_id` は、その要素が属する `namespaces` テーブルのレコードの `id` を指す外部キーとする。
* 要素がグローバルスコープに属する場合、グローバル名前空間に対応する `namespaces.id` (例: 1) を格納する。

### 4. Clang Libtooling を用いた情報抽出戦略 (概要)

* **4.1. `CursorKind.NAMESPACE` の検出:**
    * AST走査中に `clang.cindex.CursorKind.NAMESPACE` を持つカーソルを処理対象とする。
    * `cursor.spelling` から名前空間名を取得。
    * `cursor.displayname == ""` や `cursor.is_anonymous()` で匿名性を判断。
    * `cursor.location` から定義位置を取得。
* **4.2. スコープスタックを用いた現在の名前空間の追跡:**
    * `traverse_ast` 関数内で、現在処理中の名前空間のID (`namespaces.id`) を保持するスタックを管理する。
    * `NAMESPACE` カーソルに入る際に、対応する `namespaces.id` をスタックにプッシュ。
    * `NAMESPACE` カーソルから出る際にスタックからポップ。
    * 要素（関数、変数など）の定義を検出した際は、スタックのトップにある `namespace_id` をその要素が属する名前空間のIDとして使用する。
* **4.3. FQN の動的生成ロジック:**
    * `NAMESPACE` カーソルを処理する際、親のFQN (スコープスタックの一つ前のレベルのFQN、あるいは親の`namespaces`レコードから取得) と現在のカーソルの名前を結合して、現在の名前空間のFQNを生成する。
    * ルートとなるグローバル名前空間のFQNは `"(global)"` とする。
* **4.4. 各要素定義時の現在の名前空間の特定:**
    * 関数、変数などの定義カーソルを処理する際、スコープスタックのトップにある `namespace_id` を取得し、データベースに記録する際に使用する。

---

この計画書に基づき、次のステップとしてデータベーススキーマの具体的な変更定義 (`CREATE TABLE`, `ALTER TABLE` 文) や、パーサー内の詳細な処理フローの設計に進むことができます。